// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package repository

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"games/app/internal/model"
)

func newSteamGame(db *gorm.DB, opts ...gen.DOOption) steamGame {
	_steamGame := steamGame{}

	_steamGame.steamGameDo.UseDB(db, opts...)
	_steamGame.steamGameDo.UseModel(&model.SteamGame{})

	tableName := _steamGame.steamGameDo.TableName()
	_steamGame.ALL = field.NewAsterisk(tableName)
	_steamGame.ID = field.NewUint64(tableName, "id")
	_steamGame.CnName = field.NewString(tableName, "cn_name")
	_steamGame.Name = field.NewString(tableName, "name")
	_steamGame.SteamAppid = field.NewString(tableName, "steam_appid")
	_steamGame.Cc = field.NewString(tableName, "cc")
	_steamGame.L = field.NewString(tableName, "l")
	_steamGame.HeaderImage = field.NewString(tableName, "header_image")
	_steamGame.CapsuleImage = field.NewString(tableName, "capsule_image")
	_steamGame.CoverImage = field.NewString(tableName, "cover_image")
	_steamGame.BackgroundImage = field.NewString(tableName, "background_image")
	_steamGame.ShortDescription = field.NewString(tableName, "short_description")
	_steamGame.AboutTheGame = field.NewString(tableName, "about_the_game")
	_steamGame.DetailDescription = field.NewString(tableName, "detail_description")
	_steamGame.RequiredAge = field.NewUint(tableName, "required_age")
	_steamGame.IsViolent = field.NewUint(tableName, "is_violent")
	_steamGame.IsSexy = field.NewUint(tableName, "is_sexy")
	_steamGame.SupportedLanguages = field.NewString(tableName, "supported_languages")
	_steamGame.SupportChinese = field.NewUint(tableName, "support_chinese")
	_steamGame.IsFree = field.NewUint(tableName, "is_free")
	_steamGame.HaveDic = field.NewUint(tableName, "have_dic")
	_steamGame.DicIds = field.NewString(tableName, "dic_ids")
	_steamGame.PriceCurrency = field.NewString(tableName, "price_currency")
	_steamGame.PriceInitial = field.NewUint(tableName, "price_initial")
	_steamGame.PriceFinal = field.NewUint(tableName, "price_final")
	_steamGame.PriceDiscountPercent = field.NewFloat64(tableName, "price_discount_percent")
	_steamGame.PriceUnit = field.NewString(tableName, "price_unit")
	_steamGame.Windows = field.NewUint(tableName, "windows")
	_steamGame.Mac = field.NewUint(tableName, "mac")
	_steamGame.Linux = field.NewUint(tableName, "linux")
	_steamGame.Network = field.NewUint(tableName, "network")
	_steamGame.Images = field.NewUint(tableName, "images")
	_steamGame.Movies = field.NewUint(tableName, "movies")
	_steamGame.Genre = field.NewString(tableName, "genre")
	_steamGame.Developers = field.NewString(tableName, "developers")
	_steamGame.Publishers = field.NewString(tableName, "publishers")
	_steamGame.ContentDescriptorsNotes = field.NewString(tableName, "content_descriptors_notes")
	_steamGame.ComingSoon = field.NewUint(tableName, "coming_soon")
	_steamGame.ReleaseDate = field.NewString(tableName, "release_date")
	_steamGame.ReleaseTime = field.NewInt(tableName, "release_time")
	_steamGame.LastModifyTime = field.NewTime(tableName, "last_modify_time")
	_steamGame.Status = field.NewUint(tableName, "status")
	_steamGame.Used = field.NewUint(tableName, "used")
	_steamGame.CreatedAt = field.NewTime(tableName, "created_at")
	_steamGame.UpdatedAt = field.NewTime(tableName, "updated_at")
	_steamGame.DeletedAt = field.NewField(tableName, "deleted_at")

	_steamGame.fillFieldMap()

	return _steamGame
}

// steamGame steam游戏
type steamGame struct {
	steamGameDo steamGameDo

	ALL                     field.Asterisk
	ID                      field.Uint64
	CnName                  field.String  // 中文名称
	Name                    field.String  // 名称
	SteamAppid              field.String  // steam_appid
	Cc                      field.String  // cc区
	L                       field.String  // 语言
	HeaderImage             field.String  // 缩略图
	CapsuleImage            field.String  // 列表缩略图
	CoverImage              field.String  // 封面图
	BackgroundImage         field.String  // 背景图
	ShortDescription        field.String  // 一句话简介
	AboutTheGame            field.String  // 关于游戏
	DetailDescription       field.String  // 简介
	RequiredAge             field.Uint    // 年龄限制
	IsViolent               field.Uint    // 包含暴力、血腥内容：1=是，2=否，3=未知
	IsSexy                  field.Uint    // 包含色情内容：1=是，2=否，3=未知
	SupportedLanguages      field.String  // 支持的语言
	SupportChinese          field.Uint    // 支持中文：1=是，2=否，3=未知
	IsFree                  field.Uint    // 免费：1=是，2=否，3=未知
	HaveDic                 field.Uint    // 有dlc：1=是，2=否，3=未知
	DicIds                  field.String  // dlc_ids
	PriceCurrency           field.String  // 价格-货币
	PriceInitial            field.Uint    // 价格-原价（分）
	PriceFinal              field.Uint    // 价格-现价（分）
	PriceDiscountPercent    field.Float64 // 价格-折扣
	PriceUnit               field.String  // 价格-单位
	Windows                 field.Uint    // 支持windows：1=是，2=否，3=未知
	Mac                     field.Uint    // 支持mac：1=是，2=否，3=未知
	Linux                   field.Uint    // 支持linux：1=是，2=否，3=未知
	Network                 field.Uint    // 联网：1=是，2=否，3=未知
	Images                  field.Uint    // 有图片：1=是，2=否，3=未知
	Movies                  field.Uint    // 有视频：1=是，2=否，3=未知
	Genre                   field.String  // 类型(多个逗号分隔)
	Developers              field.String  // 开发商(多个逗号分隔)
	Publishers              field.String  // 发行商(多个逗号分隔)
	ContentDescriptorsNotes field.String  // 提醒文案
	ComingSoon              field.Uint    // 已发布：1=是，2=否，3=未知
	ReleaseDate             field.String  // 发布时间
	ReleaseTime             field.Int     // 发布时间戳
	LastModifyTime          field.Time    // 上次更新时间
	Status                  field.Uint    // 状态：1=正常，2=审核中，3=审核拒绝，4=禁用，5=删除
	Used                    field.Uint    // 状态：1=已使用，2=未使用
	CreatedAt               field.Time
	UpdatedAt               field.Time
	DeletedAt               field.Field

	fieldMap map[string]field.Expr
}

func (s steamGame) Table(newTableName string) *steamGame {
	s.steamGameDo.UseTable(newTableName)
	return s.updateTableName(newTableName)
}

func (s steamGame) As(alias string) *steamGame {
	s.steamGameDo.DO = *(s.steamGameDo.As(alias).(*gen.DO))
	return s.updateTableName(alias)
}

func (s *steamGame) updateTableName(table string) *steamGame {
	s.ALL = field.NewAsterisk(table)
	s.ID = field.NewUint64(table, "id")
	s.CnName = field.NewString(table, "cn_name")
	s.Name = field.NewString(table, "name")
	s.SteamAppid = field.NewString(table, "steam_appid")
	s.Cc = field.NewString(table, "cc")
	s.L = field.NewString(table, "l")
	s.HeaderImage = field.NewString(table, "header_image")
	s.CapsuleImage = field.NewString(table, "capsule_image")
	s.CoverImage = field.NewString(table, "cover_image")
	s.BackgroundImage = field.NewString(table, "background_image")
	s.ShortDescription = field.NewString(table, "short_description")
	s.AboutTheGame = field.NewString(table, "about_the_game")
	s.DetailDescription = field.NewString(table, "detail_description")
	s.RequiredAge = field.NewUint(table, "required_age")
	s.IsViolent = field.NewUint(table, "is_violent")
	s.IsSexy = field.NewUint(table, "is_sexy")
	s.SupportedLanguages = field.NewString(table, "supported_languages")
	s.SupportChinese = field.NewUint(table, "support_chinese")
	s.IsFree = field.NewUint(table, "is_free")
	s.HaveDic = field.NewUint(table, "have_dic")
	s.DicIds = field.NewString(table, "dic_ids")
	s.PriceCurrency = field.NewString(table, "price_currency")
	s.PriceInitial = field.NewUint(table, "price_initial")
	s.PriceFinal = field.NewUint(table, "price_final")
	s.PriceDiscountPercent = field.NewFloat64(table, "price_discount_percent")
	s.PriceUnit = field.NewString(table, "price_unit")
	s.Windows = field.NewUint(table, "windows")
	s.Mac = field.NewUint(table, "mac")
	s.Linux = field.NewUint(table, "linux")
	s.Network = field.NewUint(table, "network")
	s.Images = field.NewUint(table, "images")
	s.Movies = field.NewUint(table, "movies")
	s.Genre = field.NewString(table, "genre")
	s.Developers = field.NewString(table, "developers")
	s.Publishers = field.NewString(table, "publishers")
	s.ContentDescriptorsNotes = field.NewString(table, "content_descriptors_notes")
	s.ComingSoon = field.NewUint(table, "coming_soon")
	s.ReleaseDate = field.NewString(table, "release_date")
	s.ReleaseTime = field.NewInt(table, "release_time")
	s.LastModifyTime = field.NewTime(table, "last_modify_time")
	s.Status = field.NewUint(table, "status")
	s.Used = field.NewUint(table, "used")
	s.CreatedAt = field.NewTime(table, "created_at")
	s.UpdatedAt = field.NewTime(table, "updated_at")
	s.DeletedAt = field.NewField(table, "deleted_at")

	s.fillFieldMap()

	return s
}

func (s *steamGame) WithContext(ctx context.Context) *steamGameDo {
	return s.steamGameDo.WithContext(ctx)
}

func (s steamGame) TableName() string { return s.steamGameDo.TableName() }

func (s steamGame) Alias() string { return s.steamGameDo.Alias() }

func (s steamGame) Columns(cols ...field.Expr) gen.Columns { return s.steamGameDo.Columns(cols...) }

func (s *steamGame) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := s.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (s *steamGame) fillFieldMap() {
	s.fieldMap = make(map[string]field.Expr, 45)
	s.fieldMap["id"] = s.ID
	s.fieldMap["cn_name"] = s.CnName
	s.fieldMap["name"] = s.Name
	s.fieldMap["steam_appid"] = s.SteamAppid
	s.fieldMap["cc"] = s.Cc
	s.fieldMap["l"] = s.L
	s.fieldMap["header_image"] = s.HeaderImage
	s.fieldMap["capsule_image"] = s.CapsuleImage
	s.fieldMap["cover_image"] = s.CoverImage
	s.fieldMap["background_image"] = s.BackgroundImage
	s.fieldMap["short_description"] = s.ShortDescription
	s.fieldMap["about_the_game"] = s.AboutTheGame
	s.fieldMap["detail_description"] = s.DetailDescription
	s.fieldMap["required_age"] = s.RequiredAge
	s.fieldMap["is_violent"] = s.IsViolent
	s.fieldMap["is_sexy"] = s.IsSexy
	s.fieldMap["supported_languages"] = s.SupportedLanguages
	s.fieldMap["support_chinese"] = s.SupportChinese
	s.fieldMap["is_free"] = s.IsFree
	s.fieldMap["have_dic"] = s.HaveDic
	s.fieldMap["dic_ids"] = s.DicIds
	s.fieldMap["price_currency"] = s.PriceCurrency
	s.fieldMap["price_initial"] = s.PriceInitial
	s.fieldMap["price_final"] = s.PriceFinal
	s.fieldMap["price_discount_percent"] = s.PriceDiscountPercent
	s.fieldMap["price_unit"] = s.PriceUnit
	s.fieldMap["windows"] = s.Windows
	s.fieldMap["mac"] = s.Mac
	s.fieldMap["linux"] = s.Linux
	s.fieldMap["network"] = s.Network
	s.fieldMap["images"] = s.Images
	s.fieldMap["movies"] = s.Movies
	s.fieldMap["genre"] = s.Genre
	s.fieldMap["developers"] = s.Developers
	s.fieldMap["publishers"] = s.Publishers
	s.fieldMap["content_descriptors_notes"] = s.ContentDescriptorsNotes
	s.fieldMap["coming_soon"] = s.ComingSoon
	s.fieldMap["release_date"] = s.ReleaseDate
	s.fieldMap["release_time"] = s.ReleaseTime
	s.fieldMap["last_modify_time"] = s.LastModifyTime
	s.fieldMap["status"] = s.Status
	s.fieldMap["used"] = s.Used
	s.fieldMap["created_at"] = s.CreatedAt
	s.fieldMap["updated_at"] = s.UpdatedAt
	s.fieldMap["deleted_at"] = s.DeletedAt
}

func (s steamGame) clone(db *gorm.DB) steamGame {
	s.steamGameDo.ReplaceConnPool(db.Statement.ConnPool)
	return s
}

func (s steamGame) replaceDB(db *gorm.DB) steamGame {
	s.steamGameDo.ReplaceDB(db)
	return s
}

type steamGameDo struct{ gen.DO }

func (s steamGameDo) Debug() *steamGameDo {
	return s.withDO(s.DO.Debug())
}

func (s steamGameDo) WithContext(ctx context.Context) *steamGameDo {
	return s.withDO(s.DO.WithContext(ctx))
}

func (s steamGameDo) ReadDB() *steamGameDo {
	return s.Clauses(dbresolver.Read)
}

func (s steamGameDo) WriteDB() *steamGameDo {
	return s.Clauses(dbresolver.Write)
}

func (s steamGameDo) Session(config *gorm.Session) *steamGameDo {
	return s.withDO(s.DO.Session(config))
}

func (s steamGameDo) Clauses(conds ...clause.Expression) *steamGameDo {
	return s.withDO(s.DO.Clauses(conds...))
}

func (s steamGameDo) Returning(value interface{}, columns ...string) *steamGameDo {
	return s.withDO(s.DO.Returning(value, columns...))
}

func (s steamGameDo) Not(conds ...gen.Condition) *steamGameDo {
	return s.withDO(s.DO.Not(conds...))
}

func (s steamGameDo) Or(conds ...gen.Condition) *steamGameDo {
	return s.withDO(s.DO.Or(conds...))
}

func (s steamGameDo) Select(conds ...field.Expr) *steamGameDo {
	return s.withDO(s.DO.Select(conds...))
}

func (s steamGameDo) Where(conds ...gen.Condition) *steamGameDo {
	return s.withDO(s.DO.Where(conds...))
}

func (s steamGameDo) Order(conds ...field.Expr) *steamGameDo {
	return s.withDO(s.DO.Order(conds...))
}

func (s steamGameDo) Distinct(cols ...field.Expr) *steamGameDo {
	return s.withDO(s.DO.Distinct(cols...))
}

func (s steamGameDo) Omit(cols ...field.Expr) *steamGameDo {
	return s.withDO(s.DO.Omit(cols...))
}

func (s steamGameDo) Join(table schema.Tabler, on ...field.Expr) *steamGameDo {
	return s.withDO(s.DO.Join(table, on...))
}

func (s steamGameDo) LeftJoin(table schema.Tabler, on ...field.Expr) *steamGameDo {
	return s.withDO(s.DO.LeftJoin(table, on...))
}

func (s steamGameDo) RightJoin(table schema.Tabler, on ...field.Expr) *steamGameDo {
	return s.withDO(s.DO.RightJoin(table, on...))
}

func (s steamGameDo) Group(cols ...field.Expr) *steamGameDo {
	return s.withDO(s.DO.Group(cols...))
}

func (s steamGameDo) Having(conds ...gen.Condition) *steamGameDo {
	return s.withDO(s.DO.Having(conds...))
}

func (s steamGameDo) Limit(limit int) *steamGameDo {
	return s.withDO(s.DO.Limit(limit))
}

func (s steamGameDo) Offset(offset int) *steamGameDo {
	return s.withDO(s.DO.Offset(offset))
}

func (s steamGameDo) Scopes(funcs ...func(gen.Dao) gen.Dao) *steamGameDo {
	return s.withDO(s.DO.Scopes(funcs...))
}

func (s steamGameDo) Unscoped() *steamGameDo {
	return s.withDO(s.DO.Unscoped())
}

func (s steamGameDo) Create(values ...*model.SteamGame) error {
	if len(values) == 0 {
		return nil
	}
	return s.DO.Create(values)
}

func (s steamGameDo) CreateInBatches(values []*model.SteamGame, batchSize int) error {
	return s.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (s steamGameDo) Save(values ...*model.SteamGame) error {
	if len(values) == 0 {
		return nil
	}
	return s.DO.Save(values)
}

func (s steamGameDo) First() (*model.SteamGame, error) {
	if result, err := s.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.SteamGame), nil
	}
}

func (s steamGameDo) Take() (*model.SteamGame, error) {
	if result, err := s.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.SteamGame), nil
	}
}

func (s steamGameDo) Last() (*model.SteamGame, error) {
	if result, err := s.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.SteamGame), nil
	}
}

func (s steamGameDo) Find() ([]*model.SteamGame, error) {
	result, err := s.DO.Find()
	return result.([]*model.SteamGame), err
}

func (s steamGameDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.SteamGame, err error) {
	buf := make([]*model.SteamGame, 0, batchSize)
	err = s.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (s steamGameDo) FindInBatches(result *[]*model.SteamGame, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return s.DO.FindInBatches(result, batchSize, fc)
}

func (s steamGameDo) Attrs(attrs ...field.AssignExpr) *steamGameDo {
	return s.withDO(s.DO.Attrs(attrs...))
}

func (s steamGameDo) Assign(attrs ...field.AssignExpr) *steamGameDo {
	return s.withDO(s.DO.Assign(attrs...))
}

func (s steamGameDo) Joins(fields ...field.RelationField) *steamGameDo {
	for _, _f := range fields {
		s = *s.withDO(s.DO.Joins(_f))
	}
	return &s
}

func (s steamGameDo) Preload(fields ...field.RelationField) *steamGameDo {
	for _, _f := range fields {
		s = *s.withDO(s.DO.Preload(_f))
	}
	return &s
}

func (s steamGameDo) FirstOrInit() (*model.SteamGame, error) {
	if result, err := s.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.SteamGame), nil
	}
}

func (s steamGameDo) FirstOrCreate() (*model.SteamGame, error) {
	if result, err := s.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.SteamGame), nil
	}
}

func (s steamGameDo) FindByPage(offset int, limit int) (result []*model.SteamGame, count int64, err error) {
	result, err = s.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = s.Offset(-1).Limit(-1).Count()
	return
}

func (s steamGameDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = s.Count()
	if err != nil {
		return
	}

	err = s.Offset(offset).Limit(limit).Scan(result)
	return
}

func (s steamGameDo) Scan(result interface{}) (err error) {
	return s.DO.Scan(result)
}

func (s steamGameDo) Delete(models ...*model.SteamGame) (result gen.ResultInfo, err error) {
	return s.DO.Delete(models)
}

func (s *steamGameDo) withDO(do gen.Dao) *steamGameDo {
	s.DO = *do.(*gen.DO)
	return s
}
